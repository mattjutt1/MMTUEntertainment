name: Portfolio Monitoring & DORA Metrics

on:
  schedule:
    # Run every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      force_alert:
        description: 'Force alert generation for testing'
        type: boolean
        default: false
  push:
    branches: [main]
    paths:
      - '.github/workflows/portfolio-monitoring.yml'
      - 'packages/portfolio-analytics/**'

env:
  NODE_VERSION: '18'

jobs:
  collect-metrics:
    name: Collect Portfolio Metrics
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Need full history for DORA metrics
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        npm ci
        cd packages/portfolio-analytics && npm ci
    
    - name: Collect DORA Metrics
      id: dora
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        POSTHOG_API_KEY: ${{ secrets.POSTHOG_API_KEY }}
      run: |
        node -e "
        const { PortfolioDashboardDataProvider } = require('./packages/portfolio-analytics/dist/index.js');
        
        const config = {
          posthog: {
            apiKey: process.env.POSTHOG_API_KEY,
            host: 'https://app.posthog.com'
          },
          cloudflare: {
            apiToken: process.env.CLOUDFLARE_API_TOKEN,
            accountId: process.env.CLOUDFLARE_ACCOUNT_ID
          },
          github: {
            token: process.env.GITHUB_TOKEN,
            organization: 'MMTUEntertainment'
          },
          products: [
            {
              id: 'driftguard',
              name: 'DriftGuard',
              repository: 'MMTUEntertainment/DriftGuard-Checks',
              cloudflareServiceId: 'driftguard-service',
              deploymentEnvironments: ['production', 'staging'],
              healthEndpoint: 'https://driftguard.app/health',
              alertingConfig: {
                uptimeThreshold: 99.5,
                errorRateThreshold: 1.0,
                responseTimeThreshold: 1000
              }
            },
            {
              id: 'reports',
              name: 'Reports Platform', 
              repository: 'MMTUEntertainment/reports',
              cloudflareServiceId: 'reports-service',
              posthogProject: 'reports-analytics',
              deploymentEnvironments: ['production', 'staging'],
              healthEndpoint: '/api/health',
              alertingConfig: {
                uptimeThreshold: 99.0,
                errorRateThreshold: 2.0,
                responseTimeThreshold: 2000
              }
            }
          ]
        };
        
        async function collectMetrics() {
          try {
            const provider = new PortfolioDashboardDataProvider(config);
            const dashboard = await provider.getPortfolioDashboard('24h');
            const realtimeStatus = await provider.getRealtimeStatus();
            
            console.log('::set-output name=dashboard::' + JSON.stringify(dashboard));
            console.log('::set-output name=realtime::' + JSON.stringify(realtimeStatus));
            console.log('::set-output name=timestamp::' + new Date().toISOString());
            
            // Calculate summary metrics
            const criticalAlerts = dashboard.alerts.filter(a => a.severity === 'critical').length;
            const warningAlerts = dashboard.alerts.filter(a => a.severity === 'warning').length;
            const unhealthyProducts = dashboard.productMetrics.filter(pm => pm.healthStatus !== 'healthy').length;
            
            console.log('::set-output name=critical_alerts::' + criticalAlerts);
            console.log('::set-output name=warning_alerts::' + warningAlerts);
            console.log('::set-output name=unhealthy_products::' + unhealthyProducts);
            
          } catch (error) {
            console.error('Error collecting metrics:', error);
            process.exit(1);
          }
        }
        
        collectMetrics();
        "
    
    - name: Store Metrics Artifact
      uses: actions/upload-artifact@v4
      with:
        name: portfolio-metrics-${{ github.run_number }}
        path: |
          packages/portfolio-analytics/dist/
        retention-days: 30
    
    - name: Update Portfolio Status Badge
      if: always()
      run: |
        # Generate dynamic status badge based on metrics
        if [ "${{ steps.dora.outputs.critical_alerts }}" -gt "0" ]; then
          STATUS="critical"
          COLOR="red"
        elif [ "${{ steps.dora.outputs.warning_alerts }}" -gt "0" ]; then
          STATUS="warning" 
          COLOR="yellow"
        elif [ "${{ steps.dora.outputs.unhealthy_products }}" -gt "0" ]; then
          STATUS="degraded"
          COLOR="orange"
        else
          STATUS="healthy"
          COLOR="green"
        fi
        
        echo "Portfolio status: $STATUS"
        echo "PORTFOLIO_STATUS=$STATUS" >> $GITHUB_ENV
    
    outputs:
      critical_alerts: ${{ steps.dora.outputs.critical_alerts }}
      warning_alerts: ${{ steps.dora.outputs.warning_alerts }}
      unhealthy_products: ${{ steps.dora.outputs.unhealthy_products }}
      dashboard_data: ${{ steps.dora.outputs.dashboard }}
      timestamp: ${{ steps.dora.outputs.timestamp }}

  alert-notifications:
    name: Send Alert Notifications
    runs-on: ubuntu-latest
    needs: collect-metrics
    if: needs.collect-metrics.outputs.critical_alerts > 0 || needs.collect-metrics.outputs.warning_alerts > 0 || github.event.inputs.force_alert == 'true'
    
    steps:
    - name: Prepare Alert Message
      id: alert
      run: |
        CRITICAL=${{ needs.collect-metrics.outputs.critical_alerts }}
        WARNING=${{ needs.collect-metrics.outputs.warning_alerts }}
        UNHEALTHY=${{ needs.collect-metrics.outputs.unhealthy_products }}
        TIMESTAMP="${{ needs.collect-metrics.outputs.timestamp }}"
        
        if [ "$CRITICAL" -gt "0" ]; then
          SEVERITY="üö® CRITICAL"
          COLOR="danger"
        elif [ "$WARNING" -gt "0" ]; then
          SEVERITY="‚ö†Ô∏è WARNING"
          COLOR="warning" 
        else
          SEVERITY="‚ÑπÔ∏è INFO"
          COLOR="good"
        fi
        
        MESSAGE="$SEVERITY: Portfolio Health Alert
        
        üìä **Portfolio Status Update** - $TIMESTAMP
        
        üî¥ Critical Alerts: $CRITICAL
        üü° Warning Alerts: $WARNING  
        üè• Unhealthy Products: $UNHEALTHY
        
        üìà **View Dashboard**: https://portfolio-dashboard.mmtu.app
        üîß **Take Action**: Review alerts and investigate issues
        
        Generated by Portfolio Monitoring Workflow"
        
        echo "MESSAGE<<EOF" >> $GITHUB_OUTPUT
        echo "$MESSAGE" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "SEVERITY=$SEVERITY" >> $GITHUB_OUTPUT
        echo "COLOR=$COLOR" >> $GITHUB_OUTPUT
    
    - name: Create GitHub Issue for Critical Alerts
      if: needs.collect-metrics.outputs.critical_alerts > 0
      uses: actions/github-script@v7
      with:
        script: |
          const title = `üö® Critical Portfolio Alert - ${new Date().toISOString().split('T')[0]}`;
          const body = `${{ steps.alert.outputs.MESSAGE }}
          
          ## Automated Response Required
          
          This issue was automatically created due to critical alerts in the portfolio.
          
          ### Next Steps:
          - [ ] Investigate critical alerts
          - [ ] Check service health endpoints  
          - [ ] Review recent deployments
          - [ ] Update incident status
          - [ ] Close issue when resolved
          
          **Auto-generated by Portfolio Monitoring**`;
          
          // Check if similar issue already exists
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'portfolio-alert,critical',
            state: 'open'
          });
          
          if (issues.length === 0) {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['portfolio-alert', 'critical', 'automated']
            });
          } else {
            // Update existing issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issues[0].number,
              body: `**Updated Alert**: ${new Date().toISOString()}\n\n${body}`
            });
          }
    
    - name: Send Slack Notification
      if: vars.SLACK_WEBHOOK_URL
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            "text": "${{ steps.alert.outputs.SEVERITY }} Portfolio Alert",
            "attachments": [
              {
                "color": "${{ steps.alert.outputs.COLOR }}",
                "fields": [
                  {
                    "title": "Critical Alerts",
                    "value": "${{ needs.collect-metrics.outputs.critical_alerts }}",
                    "short": true
                  },
                  {
                    "title": "Warning Alerts", 
                    "value": "${{ needs.collect-metrics.outputs.warning_alerts }}",
                    "short": true
                  },
                  {
                    "title": "Unhealthy Products",
                    "value": "${{ needs.collect-metrics.outputs.unhealthy_products }}",
                    "short": true
                  },
                  {
                    "title": "Timestamp",
                    "value": "${{ needs.collect-metrics.outputs.timestamp }}",
                    "short": true
                  }
                ],
                "actions": [
                  {
                    "type": "button",
                    "text": "View Dashboard",
                    "url": "https://portfolio-dashboard.mmtu.app"
                  }
                ]
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
    
    - name: Log Alert Summary
      run: |
        echo "üîî Alert notification sent successfully"
        echo "Severity: ${{ steps.alert.outputs.SEVERITY }}"
        echo "Critical: ${{ needs.collect-metrics.outputs.critical_alerts }}"
        echo "Warning: ${{ needs.collect-metrics.outputs.warning_alerts }}"
        echo "Unhealthy: ${{ needs.collect-metrics.outputs.unhealthy_products }}"

  update-dashboard:
    name: Update Dashboard Data
    runs-on: ubuntu-latest
    needs: collect-metrics
    if: always()
    
    steps:
    - name: Store Dashboard Data
      run: |
        # In a real implementation, this would push data to a time-series database
        # or update a dashboard data store. For now, we'll log the data.
        
        echo "üìä Dashboard data collected successfully"
        echo "Timestamp: ${{ needs.collect-metrics.outputs.timestamp }}"
        echo "Data available for dashboard consumption"
        
        # Example: Push to time-series database
        # curl -X POST "https://api.timeseriesdb.com/v1/metrics" \
        #   -H "Authorization: Bearer ${{ secrets.TSDB_TOKEN }}" \
        #   -H "Content-Type: application/json" \
        #   -d '${{ needs.collect-metrics.outputs.dashboard_data }}'
    
    - name: Update Status Page
      if: vars.STATUS_PAGE_WEBHOOK
      run: |
        # Update external status page if configured
        curl -X POST "${{ vars.STATUS_PAGE_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{
            "status": "${{ env.PORTFOLIO_STATUS }}",
            "timestamp": "${{ needs.collect-metrics.outputs.timestamp }}",
            "critical_alerts": ${{ needs.collect-metrics.outputs.critical_alerts }},
            "warning_alerts": ${{ needs.collect-metrics.outputs.warning_alerts }}
          }'

  performance-analysis:
    name: DORA Performance Analysis
    runs-on: ubuntu-latest
    needs: collect-metrics
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Analyze DORA Trends
      run: |
        echo "üìà Analyzing DORA metrics trends..."
        
        # In a real implementation, this would:
        # 1. Compare current metrics to historical trends
        # 2. Identify performance regressions  
        # 3. Generate improvement recommendations
        # 4. Create performance reports
        
        echo "DORA analysis completed"
        
        # Example metrics analysis
        if [ "${{ needs.collect-metrics.outputs.critical_alerts }}" -gt "5" ]; then
          echo "::warning::High number of critical alerts detected - review incident response processes"
        fi
    
    - name: Generate Performance Report
      run: |
        cat > performance-report.md << EOF
        # Portfolio Performance Report
        
        **Generated**: ${{ needs.collect-metrics.outputs.timestamp }}
        **Workflow**: ${{ github.workflow }} #${{ github.run_number }}
        
        ## Summary
        - Critical Alerts: ${{ needs.collect-metrics.outputs.critical_alerts }}
        - Warning Alerts: ${{ needs.collect-metrics.outputs.warning_alerts }}
        - Unhealthy Products: ${{ needs.collect-metrics.outputs.unhealthy_products }}
        
        ## Recommendations
        - Monitor critical alerts and ensure rapid response
        - Review alerting thresholds for accuracy
        - Implement automated remediation where possible
        
        ## Next Actions
        - [ ] Review dashboard at https://portfolio-dashboard.mmtu.app
        - [ ] Address any critical alerts immediately
        - [ ] Schedule team review of DORA metrics trends
        
        ---
        *Automated by Portfolio Monitoring Workflow*
        EOF
        
        echo "üìã Performance report generated"
    
    - name: Archive Report
      uses: actions/upload-artifact@v4
      with:
        name: performance-report-${{ github.run_number }}
        path: performance-report.md
        retention-days: 90